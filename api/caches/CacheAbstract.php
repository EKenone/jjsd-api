<?php

namespace api\caches;

use api\caches\interfaces\CacheInterface;
use common\helpers\BaseHelper;
use yii\base\BaseObject;
use yii\base\UserException;
use yii\data\ActiveDataProvider;
use yii\db\Exception;
use yii\helpers\Json;
use yii\redis\Connection;

abstract class CacheAbstract extends BaseObject implements CacheInterface
{
    /**
     * 列表数据
     * @var array|ActiveDataProvider
     */
    public $provider;

    /**
     * 这里是设置\Yii::$app->request->get()的参数，
     * 就是搜索的时候用的字段，当然，也可以自己push一些进去
     *
     * @var array 请求的参数
     */
    public $params = [];

    /**
     * 用法说明，其实就是用于分表基于某一个标识，对table分表
     * 假如我这边有一个cc_broker表, group是集团的ID，这样就是对cc_broker表每一个集团分一个redis哈希表
     * 这样redis会根据基于集团ID的多张哈希表（hmset一个key其实就是一张哈希表,每个field就是一行数据）
     *
     * @var mixed 缓存分组标识
     */
    public $group;

    /**
     * @var bool 缓存不需要分组
     */
    public $noGroup = false;

    /**
     * 用户自动加载子类的扩展字段方法
     * 例如：
     *      想加载子类的expandIndex方法就设置为index
     *      想加载expandIndexList 就设置为indexList或者index_list
     *
     * @var string 额外字段的后缀
     */
    public $expandSuffix;

    /**
     * 这个是模型表的名字，子类必须要实现tableName()方法
     *
     * @var string 表的名字
     */
    private $_table;

    /**
     * @var Connection Redis连接
     */
    private $_redis;

    /**
     * @var bool 是否刷新
     */
    private $_refresh;

    public function init()
    {
        parent::init(); // TODO: Change the autogenerated stub
        $this->_redis = \Yii::$app->redis;
    }

    /**
     * 缓存表明
     * @return string
     */
    abstract public static function tableName(): string;

    /**
     * 获取数据，没有缓存数据的时候会直接返回Provider
     * @return mixed|ActiveDataProvider
     * @throws UserException
     * @throws Exception
     * @throws \yii\base\Exception
     */
    public function getData()
    {
        if ($this->queryDb()) {// 如果是直接请求BD，或者要刷新
            return $this->provider;
        }

        // 获取缓存
        $data = $this->_redis->hget($this->cacheKey(), $this->requestParamsKeyFilter());
        if ($data && !$this->needRefresh()) {// 如果有缓存数据,不需要刷新缓存
            $data = Json::decode($data);
            if ($data['CC_TABLE_CACHE_EXPIRED'] >= time()) {  // field的寿命没有终结
                return $data;
            }
        }

        // 如果没有缓存数据需要刷新缓存的时候，就进行防止缓存击穿DB排队 (ps:刷新也需要是因为担心同一时刻，很多人触发了刷新)
        return $this->preventBreakdownCache();
    }

    /**
     * 设置数据
     * @param array $data
     * @return array|mixed
     * @throws UserException
     */
    public function setData($data = [])
    {
        $data = array_merge($data, $this->expandData());

        if (!$this->queryDb()) {// 不是直接db，需要把数据缓存下来
            $data = array_merge($data, ['CC_TABLE_CACHE_EXPIRED' => time() + $this->expired()]); // 每个field都有寿命
            $this->_redis->hmset($this->cacheKey(), $this->requestParamsKeyFilter(), Json::encode($data));
            $this->_redis->expire($this->cacheKey(), $this->expired());// 只要有人用当前tableName的哈希表就持续更新，就延长寿命
        }

        return $data;
    }

    /**
     * 删除缓存数据
     * @return mixed|void
     * @throws UserException
     */
    public function delData()
    {
        // 单独删除某个分组
        if ($this->getGroup() || $this->noGroup) {// 有缓存标识，或者不需要缓存标识
            $this->_redis->del($this->cacheKey());
            return true;
        }

        // 全表缓存清除
        $cursor = 0;
        do {
            list($cursor, $keys) = $this->_redis->scan($cursor, 'MATCH', $this->cacheKey() . '*');
            if ($keys) {
                foreach ($keys as $key) {
                    $this->_redis->del($key);
                }
            }
        } while ($cursor);
    }

    /**
     * 设置缓存标识
     * @param mixed $group
     */
    public function setGroup($group): void
    {
        $this->group = $group;
    }

    /**
     * 获取缓存标识
     * @return string
     */
    public function getGroup()
    {
        return $this->group;
    }

    /**
     * 过期时间，如果想改时间，直接在继承类下面重写
     * @return int
     */
    public function expired()
    {
        return 600;
    }

    /**
     * 缓存分组标识数据库字段，要注意先后顺序，不然清除缓存的时候会拼接过错误
     * 如: {group_id}_{area_id}_{au_id} 那数组应该是
     *
     * [
     *      'group_id',
     *      'area_id',
     *      'au_id'
     * ]
     *
     * 当前业务情况，建议尽量只用group_id分组
     *
     * @return array
     */
    public function groupDbFields(): array
    {
        return [];
    }

    /**
     * 模糊查询的字段，存在模糊查询的都不能缓存查询，使用模糊查询的存储会产生大量不定因素数据，会导致redis占用非常高
     * 包括 <= >= between like 类似于这样的，如时间查询和关键字查询的字段
     *
     * @return string[]
     */
    protected function likeFields()
    {
        return [];
    }

    /**
     * 获取刷新值
     * @return bool|mixed
     * @throws UserException
     */
    public function needRefresh()
    {
        if (is_null($this->_refresh)) {
            $this->_refresh = $this->refresh();
        }

        return $this->_refresh;
    }

    /**
     * 是否需要刷新缓存, 子类可以继承这个方法重写刷新逻辑
     * @return mixed
     * @throws UserException
     */
    protected function refresh()
    {
        $refresh = false;
        if ($this->params['refresh'] ?? false) {
            $refresh = true;
        }

        if ($this->autoRefresh()) {
            $refresh = true;
        }

        return $refresh;
    }

    /**
     * 自动刷新，10秒内有3次或以上的同一请求，自动刷新
     * @return bool
     * @throws UserException
     */
    protected function autoRefresh()
    {
        $key = $this->cacheKey() . ':COUNTER:' . $this->requestParamsKeyFilter();
        $inc = $this->_redis->incr($key);
        if ($inc <= 1) {
            $this->_redis->expire($key, 10);
        }

        if ($inc > 2) {// 刷新了之后要重新来过
            $this->_redis->del($key);
        }

        return $inc > 2;
    }

    /**
     * 直接查询数据库
     * @return bool
     */
    protected function queryDb()
    {
        $bool = false;
        if ($this->issetLikeFields()) {
            $bool = true;
        }
        return $bool;
    }

    /**
     * 是否存着模糊查询参数
     * @return bool
     */
    protected function issetLikeFields()
    {
        foreach ($this->likeFields() as $field) {
            if (key_exists($field, $this->params) && $this->params[$field]) {
                return true;
            }
        }
        return false;
    }

    /**
     * 设置表名
     * @throws UserException
     */
    private function setTableName()
    {
        $this->_table = static::tableName();
        if (!$this->_table) {
            throw new UserException('请设置表名');
        }
    }

    /**
     * 获取表名
     * @return string
     * @throws UserException
     */
    private function getTableName()
    {
        if (!$this->_table) {
            $this->setTableName();
        }

        return $this->_table;
    }

    /**
     * 额外的数据
     * @return array
     */
    private function expandData()
    {
        $method = '';
        if ($this->expandSuffix) {
            $method = 'expand' . BaseHelper::convertUnderline($this->expandSuffix, true);
        } elseif ($this->params['scenes'] ?? false) {
            $method = 'expand' . BaseHelper::convertUnderline($this->params['scenes'], true);
        }

        return $method && method_exists($this, $method) ? call_user_func([$this, $method]) : [];
    }

    /**
     * 防止击穿缓存
     * @return array|mixed|null
     * @throws UserException
     * @throws Exception
     * @throws \yii\base\Exception
     */
    private function preventBreakdownCache()
    {
        $retry = 1;
        while (!$this->_redis->executeCommand('SET', [$this->cacheBreakdownKey(), \Yii::$app->security->generateRandomString(10), 'NX', 'EX', 5])) {// 设置setnx()成功就跳过这个步骤，不用主动清锁，让他自动过期回收
            usleep(1000 * 50); // 默认50毫秒查一次

            $data = $this->_redis->hget($this->cacheKey(), $this->requestParamsKeyFilter());
            if ($data) {
                return Json::decode($data);
            }

            if ($retry > 60) { // 60次之后(即3秒后)，让用户直接查数据库， 如果业务3秒没有查询完毕，需要优化业务
                break;
            }

            $retry++;
        }

        return $this->provider;
    }

    /**
     * 缓存击穿key
     * @return string
     * @throws UserException
     */
    private function cacheBreakdownKey()
    {
        return $this->cacheKey() . ':BREAKDOWN:' . $this->requestParamsKeyFilter();
    }

    /**
     * 缓存key
     * @return string
     * @throws UserException
     */
    final public function cacheKey()
    {
        $key = 'CACHE_MODEL:CC_TABLE_CACHE:' . strtoupper($this->getTableName());
        if ($this->getGroup() && !$this->noGroup) {
            $key .= ':GROUP_' . $this->getGroup();
        }

        return $key;
    }

    /**
     * 过滤模糊查询的参数
     * @return string
     */
    final public function requestParamsKeyFilter()
    {
        $params = $this->params;
        foreach ($this->likeFields() as $field) {
            unset($params[$field]);
        }

        return md5(http_build_query($params));
    }

}